{"version":3,"file":"index.cjs","sources":["../src/errors/createError.ts","../src/errors/errors.ts","../src/util/encoding/stringFromBuffer.ts","../src/util/encoding/textEncoder.ts","../src/util/getWindow.ts","../src/util/encoding/toBase64.ts","../src/util/encoding/toUrlEncodedBase64.ts","../src/util/crypto/getCrypto.ts","../src/util/crypto/getRandomBytes.ts","../src/util/crypto/getCryptoSubtle.ts","../src/util/crypto/sha256.ts","../src/util/crypto/createCodeChallengeAndVerifier.ts","../src/util/encoding/fromBase64.ts","../src/util/encoding/textDecoder.ts","../src/util/uniqueElementsFromArray.ts","../src/util/getSortedScope.ts","../src/util/objectFromURLSearchParams.ts","../src/util/objectToKey.ts","../src/util/index.ts","../src/util/crypto/verifyIdToken.ts","../src/util/encoding/decodeState.ts","../src/util/encoding/encodeState.ts","../src/util/objectFromEntries.ts","../src/util/retry.ts","../src/api/ApiError.ts","../src/api/Api.ts","../src/util/getScopesList.ts","../src/ClientStore.ts","../src/store/StorageStore.ts","../src/Client.ts","../src/version.ts"],"sourcesContent":["export default function createError(name: string, message: string) {\n  return class extends Error {\n    name = name\n    constructor() {\n      super(message)\n    }\n  }\n}\n","import createError from './createError'\n\nexport const PopupTimeoutError = createError(\n  'PopupTimeoutError',\n  'The popup has timed out.',\n)\n\nexport const PopupClosedError = createError(\n  'PopupClosedError',\n  'The popup was closed.',\n)\n","const stringFromBuffer = (buf: ArrayBuffer): string =>\n  String.fromCharCode.apply(null, Array.from(new Uint8Array(buf)))\n\nexport default stringFromBuffer\n","const textEncoder = new TextEncoder()\n\nexport default textEncoder\n","import window from 'global'\n\nconst getWindow: () => Window & typeof globalThis = () => window\n\nexport default getWindow\n","import getWindow from '../getWindow'\n\nconst toBase64 = (str: string) => getWindow().btoa(str)\n\nexport default toBase64\n","import toBase64 from './toBase64'\n\nconst toUrlEncodedBase64 = (str: string) => {\n  return toBase64(str)\n    .replace(/=+$/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n\nexport default toUrlEncodedBase64\n","import getWindow from '../getWindow'\n\n//ie 11.x uses msCrypto\nconst getCrypto = () =>\n  (getWindow().crypto ?? (getWindow() as any).msCrypto) as Crypto\n\nexport default getCrypto\n","import getCrypto from './getCrypto'\n\nconst getRandomBytes = (length: number): Uint8Array =>\n  getCrypto().getRandomValues(new Uint8Array(length))\n\nexport default getRandomBytes\n","import getCrypto from './getCrypto'\n\n//safari 10.x uses webkitSubtle\nconst getCryptoSubtle = () =>\n  getCrypto().subtle ?? (getCrypto() as any).webkitSubtle\n\nexport default getCryptoSubtle\n","import getWindow from '../getWindow'\nimport getCryptoSubtle from './getCryptoSubtle'\n\nconst sha256 = async (buf: ArrayBuffer): Promise<ArrayBuffer> => {\n  const digestOp: any = getCryptoSubtle().digest({name: 'SHA-256'}, buf)\n\n  // This is for legacy IE Hashing\n  if ((getWindow() as any).msCrypto) {\n    return new Promise((res, rej) => {\n      digestOp.oncomplete = (e: any) => res(e.target.result)\n      digestOp.onerror = (e: ErrorEvent) => rej(e.error)\n      digestOp.onabort = () => rej('The digest operation was aborted')\n    })\n  }\n\n  return await digestOp\n}\n\nexport default sha256\n","import type {CodeChallengeMethod} from '../../types'\nimport stringFromBuffer from '../encoding/stringFromBuffer'\nimport textEncoder from '../encoding/textEncoder'\nimport toUrlEncodedBase64 from '../encoding/toUrlEncodedBase64'\nimport getRandomBytes from './getRandomBytes'\nimport sha256 from './sha256'\n\nconst pkceMask =\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.'\n\nconst createCodeVerifier = (length: number) => {\n  return Array.from(getRandomBytes(length))\n    .map(v => pkceMask[v % pkceMask.length])\n    .join('')\n}\n\nconst createCodeChallengeAndVerifier = async (\n  length = 43,\n  method: CodeChallengeMethod = 'S256',\n): Promise<{verifier: string; challenge: string}> => {\n  const verifier = createCodeVerifier(length)\n\n  switch (method) {\n    case 'plain':\n      return {verifier, challenge: verifier}\n    case 'S256':\n      return {\n        verifier,\n        challenge: toUrlEncodedBase64(\n          stringFromBuffer(await sha256(textEncoder.encode(verifier).buffer)),\n        ),\n      }\n    default:\n      throw new Error('bad challenge method')\n  }\n}\n\nexport default createCodeChallengeAndVerifier\n","import getWindow from '../getWindow'\n\nconst fromBase64 = (str: string): string => getWindow().atob(str)\n\nexport default fromBase64\n","const textDecoder = new TextDecoder()\n\nexport default textDecoder\n","export default function uniqueElementsFromArray<T>(arr: T[]): T[] {\n  return Array.from(new Set(arr))\n}\n","import uniqueElementsFromArray from './uniqueElementsFromArray'\n\nconst getSortedScope = (scope: string) =>\n  uniqueElementsFromArray(scope.trim().split(/\\s+/)).sort().join(' ')\n\nexport default getSortedScope\n","export default function objectFromURLSearchParams(\n  params: URLSearchParams,\n): Record<string, string | string[]> {\n  const obj = {}\n\n  params.forEach((_, key) => {\n    if (params.getAll(key).length > 1) {\n      obj[key] = params.getAll(key)\n    } else {\n      obj[key] = params.get(key)\n    }\n  })\n\n  return obj\n}\n","export default function objectToKey(object: Record<PropertyKey, any>): string {\n  const params = new URLSearchParams(\n    [...Object.entries(object)].filter(([k, v]) => k != null && v != null),\n  )\n  params.sort()\n  return params.toString()\n}\n","import createCodeChallengeAndVerifier from './crypto/createCodeChallengeAndVerifier'\nimport getCrypto from './crypto/getCrypto'\nimport getCryptoSubtle from './crypto/getCryptoSubtle'\nimport getRandomBytes from './crypto/getRandomBytes'\nimport sha256 from './crypto/sha256'\nimport verifyIdToken from './crypto/verifyIdToken'\nimport decodeState from './encoding/decodeState'\nimport encodeState from './encoding/encodeState'\nimport fromBase64 from './encoding/fromBase64'\nimport stringFromBuffer from './encoding/stringFromBuffer'\nimport textDecoder from './encoding/textDecoder'\nimport textEncoder from './encoding/textEncoder'\nimport toBase64 from './encoding/toBase64'\nimport toUrlEncodedBase64 from './encoding/toUrlEncodedBase64'\n\nconst crypto = {\n  createCodeChallengeAndVerifier,\n  getCrypto,\n  getCryptoSubtle,\n  getRandomBytes,\n  sha256,\n  verifyIdToken,\n}\n\nconst encoding = {\n  decodeState,\n  encodeState,\n  fromBase64,\n  textDecoder,\n  textEncoder,\n  toBase64,\n  toUrlEncodedBase64,\n  stringFromBuffer,\n}\n\nexport {default as getSortedScope} from './getSortedScope'\nexport {default as getWindow} from './getWindow'\nexport {default as objectFromEntries} from './objectFromEntries'\nexport {default as objectFromURLSearchParams} from './objectFromURLSearchParams'\nexport {default as objectToKey} from './objectToKey'\nexport {default as retry} from './retry'\nexport {default as uniqueElementsFromArray} from './uniqueElementsFromArray'\nexport {crypto, encoding}\n","import {IdToken} from '@uauth/common'\nimport {jwtVerify, createRemoteJWKSet} from 'jose'\n\nconst verifyIdToken = async (\n  jwks_uri: string,\n  id_token: string,\n  nonce: string,\n  client_id: string,\n) => {\n  const {payload} = await jwtVerify(\n    id_token,\n    createRemoteJWKSet(new URL(jwks_uri)),\n    {audience: client_id},\n  )\n\n  const idToken: IdToken = payload as any\n\n  idToken.__raw = id_token\n\n  if (nonce !== idToken.nonce) {\n    throw new Error(\"nonces don't match\")\n  }\n\n  return idToken\n}\n\nexport default verifyIdToken\n","import fromBase64 from './fromBase64'\n\nconst decodeState = <T>(state: string): T => {\n  const [, v, ...b] = state.split('.')\n\n  if (b.length > 0) {\n    throw new Error('failed to decode state')\n  }\n\n  return v?.length > 0\n    ? JSON.parse(decodeURIComponent(/* unescape */ fromBase64(v)))\n    : undefined\n}\n\nexport default decodeState\n","import getRandomBytes from '../crypto/getRandomBytes'\nimport stringFromBuffer from './stringFromBuffer'\nimport toUrlEncodedBase64 from './toUrlEncodedBase64'\n\nconst encodeState = <T>(state: T): string =>\n  `${toUrlEncodedBase64(stringFromBuffer(getRandomBytes(32)))}.${\n    state == null\n      ? ''\n      : toUrlEncodedBase64(\n          /* escape */ encodeURIComponent(JSON.stringify(state)),\n        )\n  }`\n\nexport default encodeState\n","export default function objectFromEntries<T = any>(\n  entries: Iterable<readonly [PropertyKey, T]>,\n): Record<PropertyKey, T> {\n  const object: Record<PropertyKey, T> = {}\n  for (const [k, v] of entries) {\n    object[k] = v\n  }\n  return object\n}\n","function retry<T>(\n  fn: () => Promise<T>,\n  retries = 4,\n  timeout = 250,\n  factor = 2,\n  err = null,\n): Promise<T> {\n  if (retries <= 0) {\n    return Promise.reject(err)\n  }\n\n  return fn().catch(async err => {\n    await new Promise(r => setTimeout(r, timeout))\n    return retry(fn, retries - 1, timeout * factor, factor, err)\n  })\n}\n\nexport default retry\n","import {ErrorResponse} from './types'\n\nexport default class ApiError extends Error {\n  constructor(\n    public code: string,\n    public description: string,\n    public uri?: string,\n  ) {\n    super(`${code}: ${description}${uri ? `\\nSee more at ${uri}.` : ''}`)\n  }\n\n  static fromResponse(response: ErrorResponse) {\n    return new ApiError(\n      response.error,\n      response.error_description,\n      response.error_uri,\n    )\n  }\n}\n","import {PopupClosedError, PopupTimeoutError} from '../errors/errors'\nimport {UserInfo} from '../types'\nimport {objectFromURLSearchParams} from '../util'\nimport toBase64 from '../util/encoding/toBase64'\nimport ApiError from './ApiError'\nimport {\n  ApiOptions,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  AuthorizeWithDeviceRequest,\n  AuthorizeWithDeviceResponse,\n  BaseRequest,\n  IntrospectRequest,\n  IntrospectResponse,\n  JWKSRequest,\n  JWKSResponse,\n  LogoutRequest,\n  PopupConfig,\n  RevokeRequest,\n  TokenRequest,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  TokenWithClientCredentialsRequest,\n  TokenWithDeviceCodeRequest,\n  TokenWithPasswordRequest,\n  TokenWithRefreshTokenRequest,\n  TokenWithSAMLRequest,\n  UserInfoRequest,\n} from './types'\n\nexport default class Api {\n  static Error = ApiError\n\n  constructor(public options: ApiOptions) {}\n\n  buildAuthorizeUrl(request: AuthorizeRequest): string {\n    return this._buildUrl(request)\n  }\n\n  buildLogoutUrl(request: LogoutRequest): string {\n    return this._buildUrl(request)\n  }\n\n  parseAuthorizeResponseFromFragment(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(\n        new URLSearchParams(new URL(url).hash.substring(1)),\n      ),\n    )\n  }\n\n  parseAuthorizeResponseFromQuery(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(new URL(url).searchParams),\n    )\n  }\n\n  async authorizeWithPopup(\n    request: AuthorizeRequest,\n    config: PopupConfig = {},\n  ): Promise<AuthorizeResponse> {\n    if (!window) {\n      throw new Error('no window in options')\n    }\n\n    const url = this.buildAuthorizeUrl(request)\n\n    let popup: Window | undefined | null = config.popup\n    const timeout: number = config.timeout ?? 3600000\n\n    if (!popup) {\n      const width = config.width ?? 600\n      const height = config.height ?? 800\n\n      popup = window.open(\n        url,\n        'uauth:authorize:popup',\n        `left=${window.screenX + (window.innerWidth - width) / 2},top=${\n          window.screenY + (window.innerHeight - height) / 2\n        },width=${width},height=${height},resizable,scrollbars=yes,status=1`,\n      )\n\n      if (!popup) {\n        throw new Error('popup failed to be constructed')\n      }\n    } else {\n      popup.location.href = url\n    }\n\n    let recievedMessage = false\n    const response: AuthorizeResponse = await new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        if (!recievedMessage) {\n          clearInterval(intervalId)\n          popup!.close()\n          reject(new PopupTimeoutError())\n        }\n      }, timeout)\n\n      const intervalId = setInterval(() => {\n        // Check if popup is closed\n        if (!recievedMessage && popup?.closed) {\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          reject(new PopupClosedError())\n        }\n\n        // Check if popup doesn't violate the \"Same-Origin\" policy and has a valid url\n        let href: string\n        let url: URL\n        let redirectUrl: URL\n        try {\n          href = popup!.location.href\n          url = new URL(href)\n          redirectUrl = new URL(request.redirect_uri)\n        } catch (error) {\n          return // Exit if not\n        }\n\n        // Check to see that the redirect was correct\n        url.hash = ''\n        if (url.href === redirectUrl.href) {\n          recievedMessage = true\n\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          popup!.close()\n\n          try {\n            resolve(this.parseAuthorizeResponseFromFragment(href))\n          } catch (error) {\n            reject(error)\n          }\n        }\n      }, 10)\n    })\n\n    return response\n  }\n\n  async authorizeWithDevice(\n    request: AuthorizeWithDeviceRequest,\n  ): Promise<AuthorizeWithDeviceResponse> {\n    return {} as any\n  }\n\n  async getToken(request: TokenRequest): Promise<TokenResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  introspect(request: IntrospectRequest): Promise<IntrospectResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  async revoke(request: RevokeRequest): Promise<void> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    await this._fetchJSON(input, init)\n  }\n\n  userinfo(request: UserInfoRequest): Promise<UserInfo> {\n    const [input, init] = this._buildRequest(request, {\n      method: 'GET',\n      headers: {Authorization: `Basic ${request.access_token}`},\n    })\n    return this._fetchJSON(input, init)\n  }\n\n  jwks(request: JWKSRequest): Promise<JWKSResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'GET'})\n    return this._fetchJSON(input, init)\n  }\n\n  getTokenWithAuthorizationCode(\n    request: TokenWithAuthorizationCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithRefreshToken(\n    request: TokenWithRefreshTokenRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithDeviceCode(\n    request: TokenWithDeviceCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithPassword(\n    request: TokenWithPasswordRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithSAML(request: TokenWithSAMLRequest): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithClientCredentials(\n    request: TokenWithClientCredentialsRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  private _buildUrl(request: BaseRequest): string {\n    const {url, ...searchParams} = request\n\n    const urlObject = new URL(url)\n\n    const params = new URLSearchParams()\n\n    for (const [k, v] of Object.entries(searchParams)) {\n      if (k != null && v != null) {\n        params.append(k, v)\n      }\n    }\n\n    urlObject.search = params.toString()\n    return urlObject.toString()\n  }\n\n  private _buildRequest(\n    request: BaseRequest,\n    options: {method: 'GET' | 'POST'; headers?: HeadersInit},\n  ): [RequestInfo, RequestInit] {\n    const {url, client_id, client_secret, client_auth_method, ...rest} = request\n    const {headers: headersInit, method} = options\n\n    const headers = new Headers(this.options.headers ?? [])\n\n    new Headers(headersInit ?? []).forEach((value, key) => {\n      headers.set(key, value)\n    })\n\n    if (options.method === 'POST') {\n      headers.set('Content-Type', 'application/x-www-form-urlencoded')\n    }\n\n    const body: Record<string, any> = {\n      client_id,\n      ...rest,\n    }\n\n    switch (client_auth_method) {\n      case 'client_secret_basic':\n        // throw new Error('only client_secret_post supported')\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        headers.set(\n          'Authorization',\n          `Basic ${toBase64(`${client_id}:${client_secret}`)}`,\n        )\n\n        break\n      case 'client_secret_post':\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        body.client_secret = client_secret\n\n        break\n      case 'none':\n      case undefined:\n      case null:\n        break\n      default:\n        throw new Error('Bad client_auth_method')\n    }\n\n    return [\n      url,\n      {\n        method,\n        headers,\n        body:\n          method === 'POST'\n            ? new URLSearchParams(Object.entries(body))\n            : undefined,\n      },\n    ]\n  }\n\n  private _validateResponse(response: any) {\n    if (response.error) {\n      throw Api.Error.fromResponse(response)\n    }\n\n    return response\n  }\n\n  private async _fetchJSON(\n    input: RequestInfo,\n    init: RequestInit,\n  ): Promise<any> {\n    if (init.headers) {\n      const headers = new Headers(init.headers)\n      headers.set('Accept', 'application/json')\n      init.headers = headers\n    } else {\n      init.headers = {Accept: 'application/json'}\n    }\n\n    const response = await window?.fetch(input, init)\n\n    const json = await response.json()\n    this._validateResponse(json)\n\n    if (!response.ok) {\n      throw new Error(\n        `${response.status} ${response.statusText}: ${JSON.stringify(json)}`,\n      )\n    }\n\n    return json\n  }\n}\n","export enum NonPremiumScopes {\n  openid = 'openid',\n  wallet = 'wallet',\n}\n\nexport enum BasicScopesEnum {\n  email = 'email',\n  badges = 'badges',\n  offline = 'offline',\n  offline_access = 'offline_access',\n  humanity_check = 'humanity_check',\n  profile = 'profile',\n  social = 'social',\n}\n\nexport enum SocialScopesEnum {\n  twitter = 'social:twitter',\n  reddit = 'social:reddit',\n  youtube = 'social:youtube',\n  discord = 'social:discord',\n  telegram = 'social:telegram',\n}\n\nexport enum ProfileScopesEnum {\n  display_name = 'profile:name',\n  profile_location = 'profile:location',\n  profile_bio = 'profile:bio',\n  ipfs_website = 'profile:ipfs_website',\n  profile_picture = 'profile:picture',\n  profile_uri = 'profile:uri',\n  profile_phone = 'profile:phone',\n}\n\nexport type PremiumScopes =\n  | BasicScopesEnum\n  | SocialScopesEnum\n  | ProfileScopesEnum\n\nexport interface ScopeDefinition {\n  optional: boolean\n}\n\nexport const NON_PREMIUM_SCOPE_CONFIG: Record<\n  NonPremiumScopes,\n  ScopeDefinition\n> = {\n  [NonPremiumScopes.openid]: {\n    optional: false,\n  },\n  [NonPremiumScopes.wallet]: {\n    optional: false,\n  },\n}\n\nexport const SCOPE_CONFIG: Record<PremiumScopes, ScopeDefinition> = {\n  [BasicScopesEnum.email]: {\n    optional: true,\n  },\n  [BasicScopesEnum.offline]: {\n    optional: false,\n  },\n  [BasicScopesEnum.offline_access]: {\n    optional: false,\n  },\n  [BasicScopesEnum.humanity_check]: {\n    optional: true,\n  },\n  [BasicScopesEnum.badges]: {\n    optional: true,\n  },\n  [BasicScopesEnum.profile]: {\n    optional: true,\n  },\n  [BasicScopesEnum.social]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.display_name]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.profile_location]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.profile_bio]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.profile_picture]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.profile_uri]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.profile_phone]: {\n    optional: true,\n  },\n  [ProfileScopesEnum.ipfs_website]: {\n    optional: true,\n  },\n  [SocialScopesEnum.twitter]: {\n    optional: true,\n  },\n  [SocialScopesEnum.reddit]: {\n    optional: true,\n  },\n  [SocialScopesEnum.youtube]: {\n    optional: true,\n  },\n  [SocialScopesEnum.discord]: {\n    optional: true,\n  },\n  [SocialScopesEnum.telegram]: {\n    optional: true,\n  },\n} as const\n\nexport const getScopesList = ({premium}): string[] => {\n  const scopes: string[] = []\n  const SCOPES_LIST = premium ? SCOPE_CONFIG : NON_PREMIUM_SCOPE_CONFIG\n  Object.keys(SCOPES_LIST).forEach(name => {\n    scopes.push(name)\n    if (SCOPES_LIST[name].optional) {\n      scopes.push(`${name}:optional`)\n    }\n  })\n  return scopes\n}\n","import {AuthorizeRequest, LogoutRequest} from './api'\nimport type Client from './Client'\nimport {Authorization, AuthorizationOptions} from './types'\nimport * as util from './util'\n\nclass ClientStore {\n  constructor(public client: Client) {}\n\n  private async get<T>(\n    key: string,\n    {mustExist = false, deleteAfter = false} = {},\n  ): Promise<T | undefined> {\n    const entry = await this.client.getStore().get(key)\n    if (entry == null) {\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    const {value, expiresAt} = entry\n    if (expiresAt !== 0 && expiresAt < Date.now()) {\n      await this.client.getStore().delete(key)\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    if (deleteAfter) {\n      await this.client.getStore().delete(key)\n    }\n\n    return value\n  }\n\n  private async set<T>(key: string, value: any, timeout = 0) {\n    await this.client.getStore().set(key, {\n      expiresAt: timeout === 0 ? 0 : Date.now() + timeout,\n      value,\n    })\n  }\n\n  async setAuthorizeRequest(request: AuthorizeRequest): Promise<void> {\n    await this.set('request', request, 300_000 /* 5 minutes */)\n  }\n  getAuthorizeRequest(): Promise<AuthorizeRequest> {\n    return this.get<AuthorizeRequest>('request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<AuthorizeRequest>\n  }\n\n  async setLogoutRequest(request: LogoutRequest): Promise<void> {\n    await this.set('logout-request', request, 300_000 /* 5 minutes */)\n  }\n  getLogoutRequest(): Promise<LogoutRequest> {\n    return this.get<LogoutRequest>('logout-request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<LogoutRequest>\n  }\n\n  async setVerifier(challenge: string, verifier: string): Promise<void> {\n    await this.set(`verifier:${challenge}`, verifier, 300_000 /* 5 minutes */)\n  }\n  getVerifier(challenge: string): Promise<string> {\n    return this.get(`verifier:${challenge}`, {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<string>\n  }\n\n  async setOpenIdConfiguration(\n    username: string,\n    openidConfiguration: any,\n    timeout: number,\n  ): Promise<void> {\n    await this.set(\n      `openidConfiguration:${username}`,\n      openidConfiguration,\n      timeout,\n    )\n  }\n  getOpenIdConfiguration(username: string): Promise<any> {\n    return this.get(`openidConfiguration:${username}`)\n  }\n\n  async setAuthorization(authorization: Authorization): Promise<void> {\n    const authorizationOptions: AuthorizationOptions = {\n      clientID: authorization.idToken.aud,\n      resource: authorization.resource,\n      scope: authorization.scope,\n      username: authorization.idToken.sub,\n    }\n\n    const expiresIn = authorization.expiresAt - Date.now()\n\n    await this.set('username', authorizationOptions.username, expiresIn)\n    await this.set(\n      await this._getAuthorizationKey(authorizationOptions),\n      authorization,\n      expiresIn,\n    )\n  }\n  async deleteAuthorization(options: AuthorizationOptions): Promise<boolean> {\n    const fallbackUsername = await this.get<string>('username')\n\n    options.username = await this._getUsername(\n      options.username,\n      fallbackUsername,\n    )\n\n    if (options.username === fallbackUsername) {\n      await this.client.getStore().delete('username')\n    }\n\n    return this.client\n      .getStore()\n      .delete(await this._getAuthorizationKey(options))\n  }\n  async getAuthorization(\n    options: AuthorizationOptions,\n  ): Promise<Authorization> {\n    return this.get(await this._getAuthorizationKey(options), {\n      mustExist: true,\n    }) as Promise<Authorization>\n  }\n\n  private async _getAuthorizationKey(\n    options: AuthorizationOptions,\n  ): Promise<string> {\n    return `authorization?${util.objectToKey({\n      username: await this._getUsername(\n        options.username,\n        await this.get('username'),\n      ),\n      clientID: options.clientID ?? this.client.fallbackLoginOptions.clientID,\n      scope: util.getSortedScope(\n        options.scope ?? this.client.fallbackLoginOptions.scope,\n      ),\n      resource: options.resource ?? this.client.fallbackLoginOptions.resource,\n    })}`\n  }\n\n  private async _getUsername(username?: string, fallbackUsername?: string) {\n    if (username == null && fallbackUsername == null) {\n      throw new Error('no username given')\n    }\n\n    return username ?? fallbackUsername\n  }\n}\n\nexport default ClientStore\n","import {Store} from './types'\n\nexport default class StorageStore implements Store {\n  constructor(public storage: Storage) {}\n\n  get(key: string): string | null {\n    const value = this.storage.getItem(key)\n\n    if (value != null) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  delete(key: string): boolean {\n    this.storage.removeItem(key)\n    return true\n  }\n\n  set(key: string, value): this {\n    this.storage.setItem(key, JSON.stringify(value))\n    return this\n  }\n}\n","import {\n  DefaultIPFSResolver,\n  DefaultIssuerResolver,\n  DefaultWebFingerResolver,\n  DomainResolver,\n  IssuerResolver,\n} from '@uauth/common'\nimport {\n  Resolution,\n  ResolutionError,\n  ResolutionErrorCode,\n} from '@unstoppabledomains/resolution'\nimport {\n  Api,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  LogoutRequest,\n  LogoutResponse,\n  PopupConfig,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  UserInfoRequest,\n} from './api'\nimport ClientStore from './ClientStore'\nimport {StorageStore, Store, StoreType} from './store'\nimport {\n  Authorization,\n  AuthorizationOptions,\n  VerifiedAddress,\n  BaseLoginOptions,\n  BaseLogoutOptions,\n  CacheOptions,\n  ClientOptions,\n  FullLoginOptions,\n  LoginCallbackOptions,\n  LoginCallbackResponse,\n  LoginOptions,\n  LogoutCallbackOptions,\n  LogoutOptions,\n  UserInfo,\n  UserOptions,\n} from './types'\nimport * as util from './util'\nimport {VERSION} from './version'\nimport {getScopesList} from './util/getScopesList'\n\nif (typeof window !== 'undefined') {\n  const _w = window as any\n  _w.UAUTH_VERSION = _w.UAUTH_VERSION || {}\n  _w.UAUTH_VERSION.JS = VERSION\n}\n\nexport default class Client {\n  util = util\n  private _clientStore = new ClientStore(this)\n  api: Api\n  fallbackIssuer: string\n  fallbackLoginOptions: BaseLoginOptions\n  fallbackLogoutOptions: BaseLogoutOptions\n  cacheOptions: CacheOptions\n  issuerResolver: IssuerResolver\n  resolution: DomainResolver\n\n  store?: Store\n  storeOptions: {\n    store?: Store\n    storeType: StoreType\n  }\n\n  getStore(): Store {\n    if (this.store) {\n      return this.store\n    }\n\n    if (this.storeOptions.store) {\n      this.store = this.storeOptions.store\n    } else {\n      const storeType = this.storeOptions.storeType\n      switch (storeType) {\n        case 'localstore':\n          this.store = new StorageStore(window.localStorage)\n          break\n        case 'sessionstore':\n          this.store = new StorageStore(window.sessionStorage)\n          break\n        case 'memory':\n          this.store = new Map<string, string>()\n          break\n        default:\n          throw new Error('Bad storeType provided')\n      }\n    }\n\n    return this.store\n  }\n\n  constructor(options: ClientOptions) {\n    this.fallbackIssuer =\n      options.fallbackIssuer ?? 'https://auth.unstoppabledomains.com'\n    this.resolution = options.resolution ?? new Resolution()\n\n    this.storeOptions = {\n      store: options.store,\n      storeType: options.storeType ?? 'localstore',\n    }\n\n    this.cacheOptions = {\n      issuer: false,\n      userinfo: true,\n      ...(options.cacheOptions ?? {}),\n    }\n\n    this.api = new Api({\n      headers: {},\n    })\n\n    this.fallbackLoginOptions = {\n      clientID: options.clientID,\n      clientSecret: options.clientSecret,\n      clientAuthMethod:\n        options.clientAuthMethod ??\n        (options.clientSecret ? 'client_secret_post' : 'none'),\n      maxAge: options.maxAge ?? 300000,\n      prompt: options.prompt ?? 'login',\n      resource: options.resource,\n      redirectUri: options.redirectUri,\n      responseMode: options.responseMode ?? 'fragment',\n      scope: options.scope ?? 'openid wallet',\n    }\n\n    this.fallbackLogoutOptions = {\n      rpInitiatedLogout:\n        options.rpInitiatedLogout ??\n        typeof options.postLogoutRedirectUri === 'string',\n      postLogoutRedirectUri: options.postLogoutRedirectUri,\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    this.issuerResolver = new DefaultIssuerResolver({\n      webfingerResolver: new DefaultWebFingerResolver({\n        ipfsResolver: new DefaultIPFSResolver((...args) =>\n          (options.createIpfsUrl || DefaultIPFSResolver.defaultCreateUrl)(\n            ...args,\n          ),\n        ),\n        domainResolver: {\n          async records(\n            domain: string,\n            keys: string[],\n          ): Promise<Record<string, string>> {\n            try {\n              const records = await self.resolution.records(domain, keys)\n              return records\n            } catch (error) {\n              if (\n                error instanceof ResolutionError &&\n                error.code === ResolutionErrorCode.UnspecifiedResolver\n              ) {\n                return {}\n              }\n              throw error\n            }\n          },\n        },\n      }),\n    })\n  }\n\n  async buildAuthorizeRequest(\n    options: Partial<LoginOptions>,\n  ): Promise<AuthorizeRequest> {\n    // TODO: Ensure nothing is missing\n    const loginOptions: FullLoginOptions = {\n      ...this.fallbackLoginOptions,\n      ...options,\n    } as FullLoginOptions\n\n    const loginHint = options.username\n\n    const openidConfiguration = await this.getOpenIdConfiguration(loginHint)\n\n    const {verifier, challenge} =\n      await util.crypto.createCodeChallengeAndVerifier(43, 'S256')\n\n    const nonce = util.encoding.toBase64(\n      util.encoding.stringFromBuffer(util.crypto.getRandomBytes(32)),\n\n      /* util.encoding.textDecoder.decode */\n    )\n\n    const state = util.encoding.encodeState(loginOptions.state)\n\n    const request: AuthorizeRequest = {\n      // Generated options\n      url: openidConfiguration.authorization_endpoint,\n      code_challenge: challenge,\n      nonce,\n      state,\n\n      // Builder options\n      flow_id: loginOptions.flowId ?? 'login',\n      login_hint: loginHint,\n\n      // Parameterized options\n      client_id: loginOptions.clientID,\n      client_secret: loginOptions.clientSecret,\n      client_auth_method: loginOptions.clientAuthMethod,\n      max_age: loginOptions.maxAge,\n      prompt: loginOptions.prompt,\n      resource: loginOptions.resource,\n      redirect_uri: loginOptions.redirectUri,\n      response_mode: loginOptions.responseMode,\n      scope: loginOptions.scope,\n\n      // Constant options\n      code_challenge_method: 'S256',\n      response_type: 'code',\n\n      // package info\n      package_name: loginOptions?.packageName || '@uauth/js',\n      package_version: loginOptions?.packageVersion || VERSION,\n\n      signup_suggestion: loginOptions.signupSuggestion,\n    }\n\n    await this._clientStore.setAuthorizeRequest(request)\n    await this._clientStore.setVerifier(challenge, verifier)\n\n    return request\n  }\n\n  async loginWithPopup(\n    options: Partial<Omit<LoginOptions, 'responseMode'>> = {},\n    config?: PopupConfig,\n  ): Promise<Authorization> {\n    ;(options as Partial<LoginOptions>).responseMode = 'fragment'\n    const request = await this.buildAuthorizeRequest(options)\n    const response = await this.api.authorizeWithPopup(request, config)\n    const authorization = await this.verifyAuthorizeResponse(request, response)\n\n    return authorization\n  }\n\n  async login(options: Partial<LoginOptions> = {}): Promise<void> {\n    const request: AuthorizeRequest = await this.buildAuthorizeRequest(options)\n\n    const url = this.api.buildAuthorizeUrl(request)\n\n    if (typeof options.beforeRedirect === 'function') {\n      await options.beforeRedirect(url)\n    }\n\n    window.location.href = url\n  }\n\n  async loginCallback<T>(\n    options?: Partial<LoginCallbackOptions>,\n  ): Promise<LoginCallbackResponse<T>> {\n    const url = options?.url ?? window.location.href\n\n    const request: AuthorizeRequest =\n      await this._clientStore.getAuthorizeRequest()\n\n    let response: AuthorizeResponse\n    if (request.response_mode === 'fragment') {\n      response = this.api.parseAuthorizeResponseFromFragment(url)\n    } else if (request.response_mode === 'query') {\n      response = this.api.parseAuthorizeResponseFromQuery(url)\n    } else {\n      throw new Error('Unsupported response_mode')\n    }\n\n    return {\n      authorization: await this.verifyAuthorizeResponse(request, response),\n      state: util.encoding.decodeState<T>(request.state),\n    }\n  }\n\n  async verifyAuthorizeResponse(\n    request: AuthorizeRequest,\n    response: AuthorizeResponse,\n  ): Promise<Authorization> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      request.login_hint,\n    )\n\n    const tokenRequest: TokenWithAuthorizationCodeRequest = {\n      url: openidConfiguration.token_endpoint,\n      client_id: request.client_id,\n      client_secret: request.client_secret,\n      client_auth_method: request.client_auth_method,\n      grant_type: 'authorization_code',\n      code: response.code,\n      code_verifier: await this._clientStore.getVerifier(\n        request.code_challenge,\n      ),\n      redirect_uri: request.redirect_uri,\n    }\n\n    const tokenResponse: TokenResponse =\n      await this.api.getTokenWithAuthorizationCode(tokenRequest)\n\n    const idToken = await util.crypto.verifyIdToken(\n      openidConfiguration.jwks_uri,\n      tokenResponse.id_token!,\n      request.nonce,\n      request.client_id,\n    )\n\n    const authorization: Authorization = {\n      accessToken: tokenResponse.access_token,\n      // TODO: The server isn't returning the scope along with the callback and\n      // I havn't found the oidc docs to figure out if this is a bug.\n      expiresAt: Date.now() + tokenResponse.expires_in * 1000,\n      idToken,\n      scope: util.getSortedScope(request.scope),\n      resource: request.resource,\n    }\n\n    await this._clientStore.setAuthorization(authorization)\n\n    return authorization\n  }\n\n  // getVerifiedAccounts retrieves all verified accounts associated with the domain\n  getVerifiedAccounts(\n    authorization: Authorization,\n    symbols: string[] = [],\n  ): VerifiedAddress[] {\n    // ensure the authorization includes verified_addresses field\n    const verifiedAddresses: VerifiedAddress[] = []\n    if (!authorization.idToken.verified_addresses) {\n      return verifiedAddresses\n    }\n    authorization.idToken.verified_addresses.forEach((record: any) => {\n      // filter for requested symbols if provided\n      if (symbols.length > 0 && !symbols.includes(record.symbol)) {\n        return\n      }\n      // include the verified address\n      verifiedAddresses.push({\n        address: record.address,\n        message: record.proof.message,\n        signature: record.proof.signature,\n        symbol: record.symbol,\n      })\n    })\n\n    // return the verified address list\n    return verifiedAddresses\n  }\n\n  // getAuthorizationAccount retrieves the address that authorized the request\n  getAuthorizationAccount(\n    authorization: Authorization,\n    type = 'sig',\n    version = 'v1',\n  ): VerifiedAddress | undefined {\n    // find the requested proof key from AMR field\n    const sigProofKeys = authorization.idToken.amr?.filter((key: string) =>\n      key.startsWith(`${version}.${type}`),\n    )\n\n    // validate the proof key is located\n    if (!sigProofKeys || sigProofKeys.length == 0) {\n      return undefined\n    }\n\n    // extract the signature address\n    const sigAddress = sigProofKeys[0].split('.')[3]\n    const verifiedAccounts = this.getVerifiedAccounts(authorization)\n    if (!verifiedAccounts) {\n      return undefined\n    }\n\n    // find and return the proof address from verified account list\n    for (const account of verifiedAccounts) {\n      if (account.address === sigAddress) {\n        return account\n      }\n    }\n  }\n\n  async getOpenIdConfiguration(username?: string): Promise<any> {\n    if (this.cacheOptions.issuer) {\n      const openidConfiguration =\n        await this._clientStore.getOpenIdConfiguration(username ?? '')\n      if (openidConfiguration) {\n        return openidConfiguration\n      }\n    }\n\n    const openidConfiguration = username\n      ? await this.issuerResolver.resolve(username, this.fallbackIssuer)\n      : await fetch(\n          this.fallbackIssuer + '/.well-known/openid-configuration',\n        ).then(resp =>\n          resp.ok\n            ? resp.json()\n            : Promise.reject(new Error('bad openid-configuration response')),\n        )\n\n    await this._clientStore.setOpenIdConfiguration(\n      username ?? '',\n      openidConfiguration,\n      typeof this.cacheOptions.issuer === 'number'\n        ? this.cacheOptions.issuer\n        : 3600_000,\n    )\n\n    return openidConfiguration\n  }\n\n  async authorization(\n    options: AuthorizationOptions = {},\n  ): Promise<Authorization> {\n    const authorization = await this._clientStore.getAuthorization(options)\n\n    if (authorization.scope && !this.checkPremiumScopes(authorization.scope)) {\n      authorization.upgrade = {\n        text: 'Please contact Unstoppable Domains to upgrade your account to access premium scopes bd@unstoppabledomains.com',\n        upgrade_for_premium: getScopesList({premium: true}).join(' '),\n      }\n    }\n\n    return authorization\n  }\n\n  checkPremiumScopes(scopes: string) {\n    return (\n      scopes\n        .split(' ')\n        .filter(el => !getScopesList({premium: false}).includes(el)).length > 0\n    )\n  }\n\n  async user(options: UserOptions = {}): Promise<UserInfo> {\n    const claims = options.claims ?? [\n      'name',\n      'given_name',\n      'family_name',\n      'middle_name',\n      'nickname',\n      'preferred_username',\n      'profile',\n      'picture',\n      'website',\n      'email',\n      'email_verified',\n      'gender',\n      'birthdate',\n      'zoneinfo',\n      'locale',\n      'phone_number',\n      'phone_number_verified',\n      'address',\n      'updated_at',\n      'wallet_address',\n      'wallet_type_hint',\n      'eip4361_message',\n      'eip4361_signature',\n      'humanity_check_id',\n    ]\n\n    const authorization = await this.authorization(options)\n\n    const userinfo: UserInfo = {\n      sub: authorization.idToken.sub,\n    }\n\n    if (authorization.upgrade) {\n      userinfo.upgrade = authorization.upgrade\n      userinfo.email = 'upgrade-for-premium'\n      userinfo.address = {\n        formatted: 'upgrade-for-premium',\n        street_address: 'upgrade-for-premium',\n        locality: 'upgrade-for-premium',\n        region: 'upgrade-for-premium',\n        postal_code: 'upgrade-for-premium',\n        country: 'upgrade-for-premium',\n      }\n      userinfo.phone_number = 'upgrade-for-premium'\n      userinfo.name = 'upgrade-for-premium'\n      userinfo.given_name = 'upgrade-for-premium'\n      userinfo.family_name = 'upgrade-for-premium'\n      userinfo.middle_name = 'upgrade-for-premium'\n      userinfo.nickname = 'upgrade-for-premium'\n      userinfo.preferred_username = 'upgrade-for-premium'\n      userinfo.profile = 'upgrade-for-premium'\n      userinfo.picture = 'https://storage.googleapis.com/unstoppable-client-assets/images/partners/avatar-placeholder.png'\n      userinfo.website = 'upgrade-for-premium'\n      userinfo.gender = 'upgrade-for-premium'\n      userinfo.birthdate = 'upgrade-for-premium'\n      userinfo.zoneinfo = 'upgrade-for-premium'\n      userinfo.locale = 'upgrade-for-premium'\n      userinfo.updated_at = 'upgrade-for-premium'\n      userinfo.humanity_check_id = 'upgrade-for-premium'\n    }\n\n    // If we should only read from cache.\n    if (this.cacheOptions.userinfo) {\n      for (const claim of claims) {\n        if (authorization.idToken[claim]) {\n          userinfo[claim] = authorization.idToken[claim]\n        }\n      }\n\n      return userinfo\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    const request: UserInfoRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      access_token: authorization.accessToken,\n      url: openidConfiguration.userinfo_endpoint,\n    }\n\n    const response = await this.api.userinfo(request)\n\n    for (const claim of claims) {\n      if (response[claim]) {\n        userinfo[claim] = response[claim]\n      }\n    }\n\n    return userinfo\n  }\n\n  async buildLogoutRequest(options: LogoutOptions): Promise<LogoutRequest> {\n    const authorization = await this.authorization(options)\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    if (openidConfiguration.end_session_endpoint == null) {\n      throw new Error('end_session_endpoint must exist')\n    }\n\n    const postLogoutRedirectUri =\n      options.postLogoutRedirectUri ??\n      this.fallbackLogoutOptions.postLogoutRedirectUri\n\n    if (postLogoutRedirectUri == null) {\n      throw new Error('postLogoutRedirectUri must be supplied')\n    }\n\n    const request: LogoutRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      url: openidConfiguration.end_session_endpoint,\n      id_token_hint: authorization.idToken.__raw,\n      post_logout_redirect_uri: postLogoutRedirectUri,\n      state: util.encoding.encodeState(options.state),\n    }\n\n    await this._clientStore.setLogoutRequest(request)\n\n    return request\n  }\n\n  async logout({\n    clientID,\n    username,\n    scope,\n    resource,\n    ...options\n  }: Partial<LogoutOptions> = {}): Promise<void> {\n    const logoutOptions: LogoutOptions = {\n      ...this.fallbackLogoutOptions,\n      ...options,\n    }\n\n    const authorizationOptions = {clientID, username, scope, resource}\n\n    if (!logoutOptions.rpInitiatedLogout) {\n      await this._clientStore.deleteAuthorization(authorizationOptions)\n      return\n    }\n\n    const request = await this.buildLogoutRequest(logoutOptions)\n\n    const url = this.api.buildLogoutUrl(request)\n\n    if (typeof logoutOptions.beforeRedirect === 'function') {\n      await logoutOptions.beforeRedirect(url)\n    }\n\n    await this._clientStore.deleteAuthorization(authorizationOptions)\n\n    window.location.href = url\n  }\n\n  async logoutCallback<T>(options: LogoutCallbackOptions = {}): Promise<T> {\n    const url = options?.url ?? window.location.href\n\n    const request: LogoutRequest = await this._clientStore.getLogoutRequest()\n\n    const response: AuthorizeResponse =\n      this.api.parseAuthorizeResponseFromQuery(url)\n\n    await this.verifyLogoutResponse(request, response)\n\n    return util.encoding.decodeState<T>(request.state)\n  }\n\n  async verifyLogoutResponse(\n    request: LogoutRequest,\n    response: LogoutResponse,\n  ): Promise<void> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n  }\n}\n","export const VERSION = \"2.8.0\";\n"],"names":["createError","name","message","_Error","_class2","_this","this","_inheritsLoose","Error","PopupTimeoutError","PopupClosedError","stringFromBuffer","buf","String","fromCharCode","apply","Array","from","Uint8Array","textEncoder","TextEncoder","getWindow","window","toBase64","str","btoa","toUrlEncodedBase64","replace","getCrypto","crypto","_getWindow$crypto","msCrypto","getRandomBytes","length","getRandomValues","getCryptoSubtle","subtle","_getCrypto$subtle","webkitSubtle","sha256","digestOp","digest","Promise","resolve","res","rej","oncomplete","e","target","result","onerror","error","onabort","reject","pkceMask","fromBase64","atob","textDecoder","TextDecoder","uniqueElementsFromArray","arr","Set","getSortedScope","scope","trim","split","sort","join","objectFromURLSearchParams","params","obj","forEach","_","key","getAll","get","objectToKey","object","URLSearchParams","Object","entries","filter","_ref","toString","createCodeChallengeAndVerifier","method","verifier","map","v","createCodeVerifier","challenge","encode","buffer","then","_sha","verifyIdToken","jwks_uri","id_token","nonce","client_id","jwtVerify","createRemoteJWKSet","URL","audience","payload","idToken","__raw","encoding","decodeState","state","_state$split","slice","JSON","parse","decodeURIComponent","undefined","encodeState","encodeURIComponent","stringify","objectFromEntries","_step","_iterator","done","_step$value","value","retry","fn","retries","timeout","factor","err","r","setTimeout","ApiError","code","description","uri","fromResponse","response","error_description","error_uri","_excluded","_excluded2","Api","options","buildAuthorizeUrl","request","_buildUrl","buildLogoutUrl","parseAuthorizeResponseFromFragment","url","_validateResponse","hash","substring","parseAuthorizeResponseFromQuery","searchParams","authorizeWithPopup","config","_config$timeout","_this2","popup","location","href","_config$width","_config$height","width","height","open","screenX","innerWidth","screenY","innerHeight","recievedMessage","timeoutId","clearInterval","intervalId","close","setInterval","redirectUrl","_popup","closed","clearTimeout","redirect_uri","authorizeWithDevice","getToken","_buildRequest","_fetchJSON","_this4$_buildRequest","introspect","_this$_buildRequest","init","revoke","_this6$_buildRequest","userinfo","_this$_buildRequest2","headers","Authorization","access_token","jwks","_this$_buildRequest3","getTokenWithAuthorizationCode","getTokenWithRefreshToken","getTokenWithDeviceCode","getTokenWithPassword","getTokenWithSAML","getTokenWithClientCredentials","_objectWithoutPropertiesLoose","urlObject","_i","_Object$entries","_Object$entries$_i","k","append","search","_this$options$headers","client_secret","client_auth_method","rest","headersInit","Headers","set","body","input","_window","_this8","Accept","fetch","json","ok","status","statusText","_NON_PREMIUM_SCOPE_CO","_SCOPE_CONFIG","NonPremiumScopes","BasicScopesEnum","SocialScopesEnum","ProfileScopesEnum","ClientStore","client","mustExist","_ref$mustExist","deleteAfter","getStore","entry","_exit","_temp3","_result","_temp","expiresAt","Date","now","_temp2","setAuthorizeRequest","getAuthorizeRequest","setLogoutRequest","getLogoutRequest","setVerifier","getVerifier","setOpenIdConfiguration","username","openidConfiguration","getOpenIdConfiguration","setAuthorization","authorization","_this14","authorizationOptions","clientID","aud","resource","sub","expiresIn","_set","_getAuthorizationKey","_this13$_getAuthoriza","call","deleteAuthorization","_this16","fallbackUsername","_getUsername","_this15$_getUsername","_temp6","_this15$client$getSto","_delete","_this15$_getAuthoriza","_temp5","getAuthorization","_get2","_this18","_this17$_getAuthoriza","_this20","util","_getUsername3","_this19$_getUsername","_options$clientID","fallbackLoginOptions","_options$resource","StorageStore","storage","getItem","_proto","removeItem","setItem","NON_PREMIUM_SCOPE_CONFIG","openid","optional","wallet","SCOPE_CONFIG","email","offline","offline_access","humanity_check","badges","profile","social","display_name","profile_location","profile_bio","profile_picture","profile_uri","profile_phone","ipfs_website","twitter","reddit","youtube","discord","telegram","getScopesList","premium","scopes","SCOPES_LIST","keys","push","_w","UAUTH_VERSION","JS","_clientStore","api","fallbackIssuer","fallbackLogoutOptions","cacheOptions","issuerResolver","resolution","store","storeOptions","_options$fallbackIssu","_options$resolution","Resolution","storeType","_options$storeType","issuer","_options$cacheOptions","clientSecret","clientAuthMethod","_options$clientAuthMe","maxAge","_options$maxAge","prompt","_options$prompt","redirectUri","responseMode","_options$responseMode","_options$scope","rpInitiatedLogout","postLogoutRedirectUri","self","DefaultIssuerResolver","webfingerResolver","DefaultWebFingerResolver","ipfsResolver","DefaultIPFSResolver","createIpfsUrl","defaultCreateUrl","arguments","domainResolver","records","domain","ResolutionError","ResolutionErrorCode","UnspecifiedResolver","localStorage","sessionStorage","Map","buildAuthorizeRequest","loginOptions","_extends","loginHint","authorization_endpoint","code_challenge","flow_id","_loginOptions$flowId","flowId","login_hint","max_age","response_mode","code_challenge_method","response_type","package_name","packageName","package_version","packageVersion","signup_suggestion","signupSuggestion","loginWithPopup","_this4","verifyAuthorizeResponse","login","_this6","beforeRedirect","loginCallback","_options$url","_this7$verifyAuthoriz","_this10","_response$code","_request$client_auth_","_openidConfiguration$","token_endpoint","_this9$_clientStore$g","_request$client_id","_request$client_secre","grant_type","code_verifier","tokenResponse","accessToken","expires_in","getVerifiedAccounts","symbols","verifiedAddresses","verified_addresses","record","includes","symbol","address","proof","signature","getAuthorizationAccount","type","version","_authorization$idToke","sigProofKeys","amr","startsWith","sigAddress","verifiedAccounts","account","_exit2","_this12","resp","checkPremiumScopes","upgrade","text","upgrade_for_premium","el","user","_options$claims","claims","formatted","street_address","locality","region","postal_code","country","phone_number","given_name","family_name","middle_name","nickname","preferred_username","picture","website","gender","birthdate","zoneinfo","locale","updated_at","humanity_check_id","_step2","_iterator2","_createForOfIteratorHelperLoose","claim","userinfo_endpoint","_step3","_iterator3","buildLogoutRequest","_options$postLogoutRe","end_session_endpoint","id_token_hint","post_logout_redirect_uri","logout","_ref2","_exit4","_temp12","_result2","logoutOptions","_temp7","_temp8","_temp13","logoutCallback","_options$url2","_options","_this22","verifyLogoutResponse"],"mappings":"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"}